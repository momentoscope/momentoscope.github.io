

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="English">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>processor.DldProcessor &#8212; HextofOfflineAnalyzer 0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">HextofOfflineAnalyzer 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../../index.html">Table Of Contents</a></h3>
<p class="caption"><span class="caption-text">Processor library</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../library/DldFlashDataframeCreator.html">1. Dataframe creator class (DldFlashDataframeCreator)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../library/DldProcessor.html">2. DldProcessor class (DldProcessor)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../library/pah.html">3. Interfacing external pah library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../library/utils.html">4. Utility functions (utils)</a></li>
</ul>
<p class="caption"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../example/binning.html">1. Binning multidimensional data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example/corrections.html">2. Corrections to FEL pulse timing</a></li>
</ul>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for processor.DldProcessor</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">dask</span>
<span class="kn">import</span> <span class="nn">dask.dataframe</span>
<span class="kn">import</span> <span class="nn">dask.multiprocessing</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">configparser</span> <span class="k">import</span> <span class="n">ConfigParser</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">_VERBOSE</span> <span class="o">=</span> <span class="kc">False</span>


<span class="c1"># For code testing (Steinn Y. Agustsson)</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">processor.DldFlashDataframeCreator</span> <span class="k">import</span> <span class="n">DldFlashProcessor</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">DldFlashProcessor</span><span class="p">()</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">runNumber</span> <span class="o">=</span> <span class="mi">19135</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">readData</span><span class="p">()</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">postProcess</span><span class="p">()</span>
    <span class="n">pptime</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">addBinning</span><span class="p">(</span><span class="s1">&#39;pumpProbeTime&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">54</span><span class="p">,</span> <span class="o">-</span><span class="mi">44</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ToF</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">addBinning</span><span class="p">(</span>
        <span class="s1">&#39;dldTime&#39;</span><span class="p">,</span> <span class="mi">630</span><span class="p">,</span> <span class="mi">670</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">processor</span><span class="o">.</span><span class="n">TOF_STEP_TO_NS</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">computeBinnedData</span><span class="p">(</span><span class="n">saveName</span><span class="o">=</span><span class="s1">&#39;test2&#39;</span><span class="p">)</span>
    <span class="c1"># processor.save_array(result,&#39;test&#39;)</span>


<div class="viewcode-block" id="DldProcessor"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor">[docs]</a><span class="k">class</span> <span class="nc">DldProcessor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This class simplifies the analysis of data files recorded during the</span>
<span class="sd">      beamtime of August 2017. It converts the electrons from the DLD into</span>
<span class="sd">      a clean table and uses DASK for binning and further analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create and manage a DASK DataFrame from the data recorded at FLASH.</span>

<span class="sd">        Attributes (loaded from SETTINGS.ini):</span>
<span class="sd">            N_CORES (int): number of available CPU cores to use.</span>
<span class="sd">            CHUNK_SIZE (int): Size of the chunks in which a parquet file will</span>
<span class="sd">                be divided.</span>
<span class="sd">            TOF_STEP_NS (float): step size in ns of the dldTime. Used to</span>
<span class="sd">                convert the step number to the ToF time in the delay line</span>
<span class="sd">                detector.</span>
<span class="sd">            TOF_STEP_EV (float): step size in eV of the dldTime. Used to</span>
<span class="sd">                convert the step number to energy of the photoemitted electrons.</span>
<span class="sd">            DATA_RAW_DIR (str): Path to raw data hdf5 files output by FLASH</span>
<span class="sd">            DATA_PARQUET_DIR (str): Path to where parquet files are stored.</span>
<span class="sd">            DATA_H5_DIR (str): Path to where hdf5 files containing binned data</span>
<span class="sd">                are stored.</span>
<span class="sd">            DATA_RESULTS_DIR (str): Path to default saving location for results</span>
<span class="sd">                in np.array, tiff stack formats etc...</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">resetBins</span><span class="p">()</span>
        <span class="c1"># initialize attributes to their type. Values are then taken from</span>
        <span class="c1"># SETTINGS.ini through initialize_attributes()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_CORES</span> <span class="o">=</span> <span class="nb">int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">UBID_OFFSET</span> <span class="o">=</span> <span class="nb">int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SIZE</span> <span class="o">=</span> <span class="nb">int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TOF_STEP_TO_NS</span> <span class="o">=</span> <span class="nb">float</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TOF_NS_TO_EV</span> <span class="o">=</span> <span class="nb">float</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TOF_STEP_TO_EV</span> <span class="o">=</span> <span class="nb">float</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ET_CONV_E_OFFSET</span> <span class="o">=</span> <span class="nb">float</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ET_CONV_T_OFFSET</span> <span class="o">=</span> <span class="nb">float</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">DATA_RAW_DIR</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DATA_H5_DIR</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DATA_PARQUET_DIR</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DATA_RESULTS_DIR</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initAttributes</span><span class="p">()</span>

        <span class="c1"># set true to use the old binning method with arange, instead of</span>
        <span class="c1"># linspace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LEGACY_BINNING</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="DldProcessor.initAttributes"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.initAttributes">[docs]</a>    <span class="k">def</span> <span class="nf">initAttributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">import_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parse settings file and assign the variables.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            import_all (bool): if True, imports all entries in settings.ini under section [processor] and [paths].</span>
<span class="sd">                if False, only imports those that match existing attribute names.</span>
<span class="sd">                False is the better choice, since it keeps better track of attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">settings</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span>
                <span class="s1">&#39;SETTINGS.ini&#39;</span><span class="p">)):</span>
            <span class="n">settings</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span>
                    <span class="s1">&#39;SETTINGS.ini&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">settings</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)),</span>
                    <span class="s1">&#39;SETTINGS.ini&#39;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">[</span><span class="n">section</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">_VERBOSE</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s1">&#39;trying: </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">entry</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                            <span class="n">settings</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">entry</span><span class="p">]))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
                    <span class="nb">setattr</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">_type</span><span class="p">(</span>
                            <span class="n">settings</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">entry</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">_VERBOSE</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">_type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">entry</span><span class="p">]))</span>
                <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_VERBOSE</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;attribute error: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">import_all</span><span class="p">:</span>  <span class="c1"># old method</span>
                        <span class="k">try</span><span class="p">:</span>  <span class="c1"># assign the attribute to the best fitting type between float, int and string</span>
                            <span class="n">f</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">entry</span><span class="p">])</span>
                            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">f</span> <span class="o">-</span> <span class="n">i</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                                <span class="n">val</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># assign Integer</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">val</span> <span class="o">=</span> <span class="n">f</span>  <span class="c1"># assign Float</span>
                            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">val</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># assign String</span>
                            <span class="nb">setattr</span><span class="p">(</span>
                                <span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="nb">str</span><span class="p">(</span>
                                    <span class="n">settings</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">entry</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span></div>

<div class="viewcode-block" id="DldProcessor.readDataframes"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.readDataframes">[docs]</a>    <span class="k">def</span> <span class="nf">readDataframes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;parquet&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Load data from a parquet or HDF5 dataframe.</span>

<span class="sd">        Access the data as hdf5 file (this is the format used internally,</span>
<span class="sd">        NOT the FLASH HDF5-files from the DAQ system!)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fileName (str): name (including path) of the folder containing hdf5</span>
<span class="sd">                files where the data was saved.</span>
<span class="sd">            format (str): either &#39;parquet&#39; to load a parquet type of dataframe,</span>
<span class="sd">                or &#39;h5&#39; or &#39;hdf5&#39; to load hdf5 dataframes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">format</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s1">&#39;parquet&#39;</span><span class="p">,</span> <span class="s1">&#39;h5&#39;</span><span class="p">,</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">],</span> <span class="s1">&#39;Invalid format for data input. Please select between parquet or h5&#39;</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;parquet&#39;</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATA_PARQUET_DIR</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATA_H5_DIR</span>
        <span class="k">if</span> <span class="n">fileName</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runNumber</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="s1">&#39;mb</span><span class="si">{}</span><span class="s1">to</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pulseIdInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulseIdInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="s1">&#39;run</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runNumber</span><span class="p">)</span>
        <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="n">fileName</span>  <span class="c1"># TODO: test if naming is correct</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;parquet&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dd</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">fileName</span> <span class="o">+</span> <span class="s2">&quot;_el&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">fileName</span> <span class="o">+</span> <span class="s2">&quot;_mb&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dd</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">(</span>
                <span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;/electrons&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SIZE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">(</span>
                <span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;/microbunches&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SIZE</span><span class="p">)</span></div>

        <span class="c1"># self.postProcess()</span>

<div class="viewcode-block" id="DldProcessor.appendDataframeParquet"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.appendDataframeParquet">[docs]</a>    <span class="k">def</span> <span class="nf">appendDataframeParquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Append data to an existing dask Parquet dataframe.</span>

<span class="sd">        This can be used to concatenate multiple DAQ runs in one dataframe.</span>
<span class="sd">        Data is taken from the dd and dd_microbunch dataframe attributes.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fileName (str): name (including path) of the folder containing</span>
<span class="sd">                parquet files where to append the new data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">divisions</span><span class="p">))</span>
        <span class="n">newdd</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">fileName</span> <span class="o">+</span> <span class="s2">&quot;_el&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newdd</span><span class="o">.</span><span class="n">divisions</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">dask</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">fileName</span> <span class="o">+</span> <span class="s2">&quot;_mb&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="DldProcessor.postProcess"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.postProcess">[docs]</a>    <span class="k">def</span> <span class="nf">postProcess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bamCorrectionSign</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kCenter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Apply corrections to the dataframe.</span>

<span class="sd">        Runs the methods to post process the dataframe. Includes BAM sign</span>
<span class="sd">        correction and polar coordinates axes generation.</span>

<span class="sd">        /!\ BAM correction is tricky and will mess up the delay histogram.</span>
<span class="sd">        This is because of strong correlation with micro bunch ID of both the</span>
<span class="sd">        BAM value and the photoemission yield, i.e. photons at the end of a</span>
<span class="sd">        Macro bunch give more photoelectrons while systematically being</span>
<span class="sd">        shifted in time.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bamCorrectionSign (int): used to apply sign to the bam correction: accepted values are 0,1,-1</span>
<span class="sd">                set to 0 to avoid applying bam correction, set to None to leave</span>
<span class="sd">                unchanged the pump probe delay information (doesnt change name).</span>
<span class="sd">                See correctBAM for details.</span>
<span class="sd">            kCenter (int,int):  position of the center of k-space in the dld</span>
<span class="sd">                detector array. If set to None, no polar coordinates are added.</span>
<span class="sd">                See createPolarCoordinates for details.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bamCorrectionSign</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correctBAM</span><span class="p">(</span><span class="n">sign</span><span class="o">=</span><span class="n">bamCorrectionSign</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kCenter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createPolarCoordinates</span><span class="p">(</span><span class="n">kCenter</span><span class="p">)</span></div>

<div class="viewcode-block" id="DldProcessor.correctBAM"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.correctBAM">[docs]</a>    <span class="k">def</span> <span class="nf">correctBAM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Correct pump probe time by BAM.</span>

<span class="sd">        Corrects the pulse to pulse jitter, and changes name from</span>
<span class="sd">        delayStageTime to pumpProbeTime. BAM correction shifts the time delay</span>
<span class="sd">        by a constant value.</span>

<span class="sd">        /!\ BAM correction is tricky and will mess up the delay histogram.</span>
<span class="sd">        This is because of strong correlation with micro bunch ID of both the</span>
<span class="sd">        BAM value and the photoemission yield, i.e. photons at the end of a</span>
<span class="sd">        Macro bunch give more photoelectrons while systematically being</span>
<span class="sd">        shifted in time.</span>

<span class="sd">        Default value is 1 since the BAM measures the delay between the master</span>
<span class="sd">        clock start and the arrival of the beam.</span>
<span class="sd">        On the other hand, more positive delay stage values are for when the FEL</span>
<span class="sd">        arrives earlier (FEL before pump is on the more positive side of t0).</span>
<span class="sd">        A bigger delay in beam arrival for an FEL pulse means that the photoelectrons</span>
<span class="sd">        actually had a more negative delay (probe later than pump) than what the delay stage</span>
<span class="sd">        measured, and should therefore be moved to more negative values.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            sign (int): sign multiplier for BAM correction</span>
<span class="sd">                accepted values: 0, 1, -1</span>
<span class="sd">                Avoid using -1 unless debugging</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="p">[</span><span class="s1">&#39;pumpProbeTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="p">[</span><span class="s1">&#39;delayStageTime&#39;</span><span class="p">]</span> <span class="o">-</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="p">[</span><span class="s1">&#39;bam&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sign</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="s1">&#39;pumpProbeTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="s1">&#39;delayStageTime&#39;</span><span class="p">]</span> <span class="o">-</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="s1">&#39;bam&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sign</span></div>

<div class="viewcode-block" id="DldProcessor.createPolarCoordinates"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.createPolarCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">createPolarCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kCenter</span><span class="o">=</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; Define polar coordinates for k-space values.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            kCenter (int,int): position of the center of k-space in the dld</span>
<span class="sd">                detector array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">radius</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">posX</span> <span class="o">-</span> <span class="n">kCenter</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">posY</span> <span class="o">-</span> <span class="n">kCenter</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">posY</span> <span class="o">-</span> <span class="n">kCenter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">df</span><span class="o">.</span><span class="n">posX</span> <span class="o">-</span> <span class="n">kCenter</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="p">[</span><span class="s1">&#39;posR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="p">[</span><span class="s1">&#39;posT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span></div>

<div class="viewcode-block" id="DldProcessor.normalizePumpProbeTime"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.normalizePumpProbeTime">[docs]</a>    <span class="k">def</span> <span class="nf">normalizePumpProbeTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_array</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># TODO: work on better implementation and accessibility for this method</span>
        <span class="sd">&quot;&quot;&quot; Normalise data to the delay stage histogram.</span>

<span class="sd">        Normalises the data array to the number of counts per delay stage step.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            data_array (np.array): data array containing binned data, as</span>
<span class="sd">            created by the computeBinnedData method.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: when no pump probe time delay axis is available.</span>

<span class="sd">        Returns:</span>
<span class="sd">            data_array_normalized: normalized version of the input array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;pumpProbeTime&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ax</span>
            <span class="n">data_array_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="n">norm_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delaystageHistogram</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">data_array_normalized</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">norm_array</span> <span class="o">=</span> <span class="n">norm_array</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;normalized pumpProbe data found along axis </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">data_array_normalized</span> <span class="o">=</span> <span class="n">data_array_normalized</span> <span class="o">/</span> <span class="n">norm_array</span>
            <span class="n">data_array_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">data_array_normalized</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data_array_normalized</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;No pump probe time bin, could not normalize to delay stage histogram.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DldProcessor.save_binned"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.save_binned">[docs]</a>    <span class="k">def</span> <span class="nf">save_binned</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binnedData</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Save a binned array to h5 file. The file includes the axes (taken from the scheduled bins)</span>
<span class="sd">        and the delay histograms, if present.</span>

<span class="sd">        Parameters:</span>

<span class="sd">            binnedData :</span>
<span class="sd">                binned data</span>
<span class="sd">            name : str</span>
<span class="sd">                extra name tag in the filename</span>
<span class="sd">            path : str | None</span>
<span class="sd">                file path</span>
<span class="sd">            mode : str | &#39;w&#39; (write)</span>
<span class="sd">                write mode of h5 file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATA_RESULTS_DIR</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;run</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">.h5&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runNumber</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">h5File</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

        <span class="c1"># Saving data</span>
        <span class="n">h5File</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;binnedData&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">binnedData</span><span class="p">)</span>

        <span class="c1"># Saving axes</span>
        <span class="n">aa</span> <span class="o">=</span> <span class="n">h5File</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;axes&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">binName</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="p">):</span>
            <span class="n">aa</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">binName</span><span class="p">),</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Saving delay histograms</span>
        <span class="n">hh</span> <span class="o">=</span> <span class="n">h5File</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;histograms&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;delaystageHistogram&#39;</span><span class="p">):</span>
            <span class="n">hh</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s1">&#39;delaystageHistogram&#39;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delaystageHistogram</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pumpProbeHistogram&#39;</span><span class="p">):</span>
            <span class="n">hh</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s1">&#39;pumpProbeHistogram&#39;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pumpProbeHistogram</span><span class="p">)</span>

        <span class="n">h5File</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="DldProcessor.load_binned"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.load_binned">[docs]</a>    <span class="k">def</span> <span class="nf">load_binned</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; load an h5 file saved with save_array.</span>

<span class="sd">        Parameters:</span>

<span class="sd">                name : str</span>
<span class="sd">                    extra name tag in the filename</span>
<span class="sd">                path : str | None</span>
<span class="sd">                    file path</span>
<span class="sd">                mode : str | &#39;r&#39; (read)</span>
<span class="sd">                    read mode of h5 file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATA_RESULTS_DIR</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;run</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">.h5&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runNumber</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">h5File</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

        <span class="c1"># Retrieving binned data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">h5File</span><span class="p">[</span><span class="s1">&#39;binnedData&#39;</span><span class="p">][()]</span>

        <span class="c1"># Retrieving axes from h5 file</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">h5File</span><span class="p">[</span><span class="s1">&#39;axes/&#39;</span><span class="p">]:</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h5File</span><span class="p">[</span><span class="s1">&#39;axes/&#39;</span> <span class="o">+</span> <span class="n">ax</span><span class="p">][()])</span>

        <span class="c1"># Retrieving delay histograms</span>
        <span class="n">hists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hist</span> <span class="ow">in</span> <span class="n">h5File</span><span class="p">[</span><span class="s1">&#39;histograms/&#39;</span><span class="p">]:</span>
            <span class="n">hists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h5File</span><span class="p">[</span><span class="s1">&#39;histograms/&#39;</span> <span class="o">+</span> <span class="n">hist</span><span class="p">][()])</span>

        <span class="n">h5File</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">hists</span></div>

    <span class="k">def</span> <span class="nf">addBinningOld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">useStepSize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_last</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_legacy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add binning of one dimension, to be then computed with computeBinnedData method.</span>

<span class="sd">        Creates a list of bin names, (binNameList) to identify the axis on</span>
<span class="sd">        which to bin the data. Output array dimensions order will be the same</span>
<span class="sd">        as in this list. The attribute binRangeList will contain the ranges of</span>
<span class="sd">        the binning used for the corresponding dimension.</span>

<span class="sd">        Binning is created using np.linspace (formerly was done with np.arange).</span>
<span class="sd">        The implementation allows to choose between setting a step size</span>
<span class="sd">        (useStepSize=True, default) or using a number of bins (useStepSize=False).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            name (string): Name of the column to bin to. Possible column names are:</span>
<span class="sd">                posX, posY, dldTime, pumpProbeTime, dldDetector, etc.</span>
<span class="sd">            start (float): position of first bin</span>
<span class="sd">            end (float): position of last bin (not included!)</span>
<span class="sd">            steps (float): define the bin size: if useStepSize=True (default),</span>
<span class="sd">                this is the step size, while if useStepSize=False, then this is the</span>
<span class="sd">                number of bins. In Legacy mode (force_legacy=True, or</span>
<span class="sd">                processor._LEGACY_MODE=True)</span>
<span class="sd">            force_legacy (bool): if true, imposes old method for generating binns,</span>
<span class="sd">                based on np.arange instead of linspace.</span>

<span class="sd">        See also:</span>
<span class="sd">            computeBinnedData : Method to compute all bins created with this function.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If the name is &#39;pumpProbeTime&#39;: sets self.delaystageHistogram for normalization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_LEGACY_BINNING</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">_LEGACY_BINNING</span> <span class="ow">or</span> <span class="n">force_legacy</span><span class="p">:</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">useStepSize</span><span class="p">:</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">%</span> <span class="n">steps</span>
            <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">-</span> <span class="n">rest</span><span class="p">)</span> <span class="o">/</span> <span class="n">steps</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">include_last</span><span class="p">:</span>
                <span class="n">n_bins</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">include_last</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">steps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;number of steps must be a positive integer number&#39;</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">include_last</span><span class="p">)</span>

        <span class="c1"># write the parameters to the bin list:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;pumpProbeTime&#39;</span><span class="p">):</span>
            <span class="c1"># self.delaystageHistogram = numpy.histogram(self.delaystage[numpy.isfinite(self.delaystage)], bins)[0]</span>
            <span class="n">delaystageHistBinner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="s1">&#39;pumpProbeTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
            <span class="n">delaystageHistGrouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                <span class="p">[</span><span class="n">delaystageHistBinner</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delaystageHistogram</span> <span class="o">=</span> <span class="n">delaystageHistGrouped</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">()[</span><span class="s1">&#39;bam&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># TODO: discuss and improve the delay stage histogram normalization.</span>

<div class="viewcode-block" id="DldProcessor.addFilter"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.addFilter">[docs]</a>    <span class="k">def</span> <span class="nf">addFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Filters the dataframes contained in the current processor</span>

<span class="sd">        Parameters:</span>
<span class="sd">            colname (str): name of the column in the dask dataframes</span>
<span class="sd">            lb (float64): lower boundary of the filter</span>
<span class="sd">            ub (float64): upper bounday of the filter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lb</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ub</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lb</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ub</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">genBins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">useStepSize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">forceEnds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_last</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_legacy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates bins for use by binning functions. Can also be used to generate x axes.</span>

<span class="sd">        Binning is created using np.linspace (formerly was done with np.arange).</span>
<span class="sd">        The implementation allows to choose between setting a step size</span>
<span class="sd">        (useStepSize=True, default) or using a number of bins (useStepSize=False).</span>

<span class="sd">        In general, it is not possible to satisfy all 3 parameters: start, end, steps.</span>
<span class="sd">        For this reason, you can choose to give priority to the step size or to the</span>
<span class="sd">        interval size. In case forceEnds=False, the steps parameter is given</span>
<span class="sd">        priority and the end parameter is redefined, so the interval can actually</span>
<span class="sd">        be larger than expected. In case forceEnds = true, the stepSize is not</span>
<span class="sd">        enforced, and the interval is divided by the closest step that divides it</span>
<span class="sd">        cleanly. This of course only has meaning when choosing steps that do not</span>
<span class="sd">        cleanly divide the interval.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            start (float): position of first bin</span>
<span class="sd">            end (float): position of last bin (not included!)</span>
<span class="sd">            steps (float): define the bin size: if useStepSize=True (default),</span>
<span class="sd">                this is the step size, while if useStepSize=False, then this is the</span>
<span class="sd">                number of bins. In Legacy mode (force_legacy=True, or</span>
<span class="sd">                processor._LEGACY_MODE=True)</span>
<span class="sd">            useStepSize (bool): tells python to interpret steps as a step size if</span>
<span class="sd">                True, or as the number of steps if False</span>
<span class="sd">            forceEnds (bool): tells python to give priority to the end parameter</span>
<span class="sd">                rather than the step parameter (see above for more info)</span>
<span class="sd">            include_last (bool): closes the interval on the right when true. If</span>
<span class="sd">                using step size priority, will expand the interval to include</span>
<span class="sd">                the next value when true, will shrink the interval to contain all</span>
<span class="sd">                points within the bounds if false.</span>
<span class="sd">            force_legacy (bool): if true, imposes old method for generating binns,</span>
<span class="sd">                based on np.arange instead of linspace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span>

        <span class="n">_LEGACY_BINNING</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># uses old method of binning</span>
        <span class="k">if</span> <span class="n">_LEGACY_BINNING</span> <span class="ow">or</span> <span class="n">force_legacy</span><span class="p">:</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>

        <span class="c1"># default interpretation of steps as the step size</span>
        <span class="c1"># needs Decimal library for dealing with float representation issues</span>
        <span class="k">elif</span> <span class="n">useStepSize</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">forceEnds</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)))</span> <span class="o">%</span>
                              <span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">steps</span><span class="p">))))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">include_last</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">steps</span><span class="p">))</span> <span class="o">-</span> \
                                     <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)))</span> <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">steps</span><span class="p">))))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">-=</span> <span class="nb">float</span><span class="p">((</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)))</span> <span class="o">%</span>
                                      <span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">steps</span><span class="p">))))</span>
                        <span class="n">include_last</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span> <span class="o">/</span> <span class="n">steps</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">include_last</span><span class="p">:</span>
                <span class="n">n_bins</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">include_last</span><span class="p">)</span>

        <span class="c1"># non default interpretation of steps as the number of steps</span>
        <span class="c1"># /!\ remember to use n+1 if including the end point (default)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">steps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;number of steps must be a positive integer number&#39;</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">include_last</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bins</span>

<div class="viewcode-block" id="DldProcessor.addBinning"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.addBinning">[docs]</a>    <span class="k">def</span> <span class="nf">addBinning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">useStepSize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forceEnds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">include_last</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_legacy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add binning of one dimension, to be then computed with computeBinnedData method.</span>

<span class="sd">        Creates a list of bin names, (binNameList) to identify the axis on</span>
<span class="sd">        which to bin the data. Output array dimensions order will be the same</span>
<span class="sd">        as in this list. The attribute binRangeList will contain the ranges of</span>
<span class="sd">        the binning used for the corresponding dimension.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            name (string): Name of the column to bin to. Possible column names are:</span>
<span class="sd">                posX, posY, dldTime, pumpProbeTime, dldDetector, etc.</span>
<span class="sd">            start (float): position of first bin</span>
<span class="sd">            end (float): position of last bin (not included!)</span>
<span class="sd">            steps (float): define the bin size: if useStepSize=True (default),</span>
<span class="sd">                this is the step size, while if useStepSize=False, then this is the</span>
<span class="sd">                number of bins. In Legacy mode (force_legacy=True, or</span>
<span class="sd">                processor._LEGACY_MODE=True)</span>
<span class="sd">            useStepSize (bool): tells python to interpret steps as a step size if</span>
<span class="sd">                True, or as the number of steps if False</span>
<span class="sd">            forceEnds (bool): tells python to give priority to the end parameter</span>
<span class="sd">                rather than the step parameter (see genBins for more info)</span>
<span class="sd">            include_last (bool): closes the interval on the right when true. If</span>
<span class="sd">                using step size priority, will expand the interval to include</span>
<span class="sd">                the next value when true, will shrink the interval to contain all</span>
<span class="sd">                points within the bounds if false.</span>
<span class="sd">            force_legacy (bool): if true, imposes old method for generating binns,</span>
<span class="sd">                based on np.arange instead of linspace.</span>
<span class="sd">        Returns:</span>
<span class="sd">            axes (np.array): axis of the binned dimesion. The points defined on this axis are the middle points of each bin.</span>

<span class="sd">        See also:</span>
<span class="sd">            computeBinnedData : Method to compute all bins created with this function.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If the name is &#39;pumpProbeTime&#39;: sets self.delaystageHistogram for normalization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># write the parameters to the bin list:</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genBins</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">useStepSize</span><span class="p">,</span> <span class="n">forceEnds</span><span class="p">,</span> <span class="n">include_last</span><span class="p">,</span> <span class="n">force_legacy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;pumpProbeTime&#39;</span><span class="p">):</span>
            <span class="c1"># self.delaystageHistogram = numpy.histogram(self.delaystage[numpy.isfinite(self.delaystage)], bins)[0]</span>
            <span class="n">delaystageHistBinner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="s1">&#39;pumpProbeTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
            <span class="n">delaystageHistGrouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                <span class="p">[</span><span class="n">delaystageHistBinner</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pumpProbeHistogram</span> <span class="o">=</span> <span class="n">delaystageHistGrouped</span><span class="o">.</span><span class="n">count</span><span class="p">(</span>
            <span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()[</span><span class="s1">&#39;bam&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;delayStageTime&#39;</span><span class="p">):</span>
            <span class="c1"># self.delaystageHistogram = numpy.histogram(self.delaystage[numpy.isfinite(self.delaystage)], bins)[0]</span>
            <span class="n">delaystageHistBinner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="p">[</span><span class="s1">&#39;delayStageTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
            <span class="n">delaystageHistGrouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddMicrobunches</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                <span class="p">[</span><span class="n">delaystageHistBinner</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delaystageHistogram</span> <span class="o">=</span> <span class="n">delaystageHistGrouped</span><span class="o">.</span><span class="n">count</span><span class="p">(</span>
            <span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()[</span><span class="s1">&#39;bam&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">useStepSize</span><span class="p">:</span>
            <span class="n">stepSize</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stepSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">steps</span>
        
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genBins</span><span class="p">(</span>
            <span class="n">start</span> <span class="o">+</span> <span class="n">stepSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">end</span> <span class="o">-</span> <span class="n">stepSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">stepSize</span><span class="p">,</span>
            <span class="n">useStepSize</span><span class="p">,</span>
            <span class="n">forceEnds</span><span class="p">,</span>
            <span class="n">include_last</span><span class="p">,</span>
            <span class="n">force_legacy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">axes</span></div>

<div class="viewcode-block" id="DldProcessor.resetBins"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.resetBins">[docs]</a>    <span class="k">def</span> <span class="nf">resetBins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the bin list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="DldProcessor.computeBinnedData"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.computeBinnedData">[docs]</a>    <span class="k">def</span> <span class="nf">computeBinnedData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">saveName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">savePath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">saveMode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Use the bin list to bin the data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (np.array): It returns a numpy array of float64 values. Number of bins defined will define the</span>
<span class="sd">            dimensions of such array.</span>

<span class="sd">        Notes:</span>
<span class="sd">            postProcess method must be used before computing the binned data if binning along pumpProbeDelay or polar</span>
<span class="sd">            k-space coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">analyzePart</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Function called by each thread of the analysis.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">grouperList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="p">)):</span>
                <span class="n">grouperList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">grouped</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">grouperList</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">grouped</span><span class="o">.</span><span class="n">count</span><span class="p">())[</span><span class="s1">&#39;microbunchId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="c1"># new binner for a partition, not using the Pandas framework. It should</span>
        <span class="c1"># be faster!</span>
        <span class="k">def</span> <span class="nf">analyzePartNumpy</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Function called by each thread of the analysis. This now should be faster.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># get the data as numpy:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">values</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span>
            <span class="c1"># create array of columns to be used for binning</span>
            <span class="n">colsToBin</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">binName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">binName</span><span class="p">)</span>
                <span class="n">colsToBin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="c1"># create the array with the bins and bin ranges</span>
            <span class="n">numBins</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">colsToBin</span><span class="p">)):</span>
                <span class="c1"># need to subtract 1 from the number of bin ranges</span>
                <span class="n">numBins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
            <span class="c1"># now we are ready for the analysis with numpy:</span>
            <span class="n">res</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span>
                <span class="n">vals</span><span class="p">[:,</span> <span class="n">colsToBin</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">numBins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">ranges</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">res</span>

        <span class="c1"># prepare the partitions for the calculation in parallel</span>
        <span class="n">calculatedResults</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">npartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_CORES</span><span class="p">)):</span>
            <span class="n">resultsToCalculate</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># process the data in blocks of n partitions (given by the number</span>
            <span class="c1"># of cores):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_CORES</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">npartitions</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">get_partition</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">resultsToCalculate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">analyzePartNumpy</span><span class="p">)(</span><span class="n">part</span><span class="p">))</span>

            <span class="c1"># now do the calculation on each partition (using the dask</span>
            <span class="c1"># framework):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resultsToCalculate</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#                print(&quot;computing partitions &quot; + str(i) + &quot; to &quot; + str(i + j) + &quot; of &quot; + str(</span>
                <span class="c1">#                    self.dd.npartitions) + &quot;. partitions calculated in parallel: &quot; + str(</span>
                <span class="c1">#                    len(resultsToCalculate)))</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">*</span><span class="n">resultsToCalculate</span><span class="p">)</span>
                <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="n">result</span>
                <span class="n">calculatedResults</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">total</span>
            <span class="k">del</span> <span class="n">resultsToCalculate</span>

        <span class="c1"># we now need to add them all up (single core):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">calculatedResults</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">calculatedResults</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">r</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">saveName</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_binned</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">saveName</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">savePath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">saveMode</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="DldProcessor.computeBinnedDataMulti"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.computeBinnedDataMulti">[docs]</a>    <span class="k">def</span> <span class="nf">computeBinnedDataMulti</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">saveName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">savePath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">saveMode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Use the bin list to bin the data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (np.array): It returns a numpy array of float64 values. Number of bins defined will define the</span>
<span class="sd">            dimensions of such array.</span>

<span class="sd">        Notes:</span>
<span class="sd">            postProcess method must be used before computing the binned data if binning along pumpProbeDelay or polar</span>
<span class="sd">            k-space coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">analyzePart</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Function called by each thread of the analysis.&quot;&quot;&quot;</span>
            <span class="n">grouperList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="p">)):</span>
                <span class="n">grouperList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">grouped</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">grouperList</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">grouped</span><span class="o">.</span><span class="n">count</span><span class="p">())[</span><span class="s1">&#39;microbunchId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="c1"># new binner for a partition, not using the Pandas framework. It should</span>
        <span class="c1"># be faster!</span>
        <span class="k">def</span> <span class="nf">analyzePartNumpy</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Function called by each thread of the analysis. This now should be faster. &quot;&quot;&quot;</span>
            <span class="c1"># get the data as numpy:</span>
            <span class="c1"># vals = part.values</span>
            <span class="c1"># cols = part.columns.values</span>
            <span class="c1"># create array of columns to be used for binning</span>
            
            <span class="n">colsToBin</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">binName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binNameList</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">binName</span><span class="p">)</span>
                <span class="n">colsToBin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="c1"># create the array with the bins and bin ranges</span>
            <span class="n">numBins</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">colsToBin</span><span class="p">)):</span>
                <span class="n">numBins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">binRangeList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
            <span class="c1"># now we are ready for the analysis with numpy:</span>
            <span class="n">res</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span>
                <span class="n">vals</span><span class="p">[:,</span> <span class="n">colsToBin</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">numBins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">ranges</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">res</span>

        <span class="c1"># prepare the partitions for the calculation in parallel</span>
        <span class="n">calculatedResults</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">npartitions</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
            <span class="n">resultsToCalculate</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># process the data in blocks of n partitions (given by the number of cores):</span>
            <span class="c1"># for j in range(0, self.N_CORES):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">rank</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">npartitions</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">partval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">get_partition</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">rank</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">partcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">get_partition</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">rank</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">analyzePartNumpy</span><span class="p">(</span><span class="n">partval</span><span class="p">,</span> <span class="n">partcol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">+=</span> <span class="n">analyzePartNumpy</span><span class="p">(</span><span class="n">partval</span><span class="p">,</span> <span class="n">partcol</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;computing partitions &quot;</span> <span class="o">+</span>
                  <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span>
                      <span class="n">rank</span><span class="p">)</span> <span class="o">+</span>
                  <span class="s2">&quot; of &quot;</span> <span class="o">+</span>
                  <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dd</span><span class="o">.</span><span class="n">npartitions</span><span class="p">)</span> <span class="o">+</span>
                  <span class="s2">&quot;. partitions calculated in parallel: &quot;</span> <span class="o">+</span>
                  <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">saveName</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_binned</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">saveName</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">savePath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">saveMode</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

    <span class="c1"># ==================</span>
    <span class="c1"># DEPRECATED METHODS</span>
    <span class="c1"># ==================</span>

    <span class="k">def</span> <span class="nf">save2hdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binnedData</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;default.hdf5&#39;</span><span class="p">,</span>
            <span class="n">normalizedData</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Store the binned data in a hdf5 file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            binneddata (pd.DataFrame): binned data with bins in dldTime, posX, and posY</span>
<span class="sd">                (and if to be normalized, binned in detectors)</span>
<span class="sd">            filename (string): name of the file,</span>
<span class="sd">            path (string, optional): path to the location where to save the hdf5 file. If None, uses the default value</span>
<span class="sd">                defined in SETTINGS.ini</span>
<span class="sd">            normalizedData (bool): Normalized data for both detector, so it should be a 3d array (posX, posY,detectorID).</span>
<span class="sd">            overwrite (bool): if True, overwrites existing files with matching name.</span>

<span class="sd">        Example:</span>
<span class="sd">            Normalization given, for example take it from run 18440.</span>

<span class="sd">            processor.readRun(18440)</span>
<span class="sd">            processor.addBinning(&#39;posX&#39;, 500, 1000, 2)</span>
<span class="sd">            processor.addBinning(&#39;posY&#39;, 500, 1000, 2)</span>
<span class="sd">            processor.addBinning(&#39;dldDetectorId&#39;, -1, 2, 1)</span>
<span class="sd">            norm = processor.computeBinnedData()</span>
<span class="sd">            norm = np.nan_to_num(norm)</span>
<span class="sd">            norm[norm&lt;10]=1 # 10 or smaller seems to be outside of detector</span>
<span class="sd">            norm[:,:,0][norm[:,:,0] &gt;= 10]/=norm[:,:,0][norm[:,:,0] &gt;= 10].mean()</span>
<span class="sd">            norm[:,:,1][norm[:,:,1] &gt;= 10]/=norm[:,:,1][norm[:,:,1] &gt;= 10].mean()</span>
<span class="sd">            norm[norm&lt;0.05]=0.1</span>

<span class="sd">            Raises:</span>
<span class="sd">                Exception Wrong dimension: if data from binnedData has dimensions different from 4</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: generalise this function for different data input shapes or bin</span>
        <span class="c1"># orders</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATA_H5_DIR</span>

        <span class="k">if</span> <span class="n">normalizedData</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">binnedData</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Wrong dimension&#39;</span><span class="p">)</span>
            <span class="n">data2hdf5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">binnedData</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="c1"># normalize for all time binns</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">binnedData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># normalize for both detectors (0 and 1)</span>

                <span class="n">data2hdf5</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">binnedData</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="p">)</span> <span class="o">/</span> <span class="n">normalizedData</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">data2hdf5</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">binnedData</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span>
                                                 <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">/</span> <span class="n">normalizedData</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># detector binned? -&gt; sum together</span>
            <span class="k">if</span> <span class="n">binnedData</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">data2hdf5</span> <span class="o">=</span> <span class="n">binnedData</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">binnedData</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Wrong dimension&#39;</span><span class="p">)</span>
                <span class="c1"># print(binnedData.transpose((1,2).shape)</span>
                <span class="n">data2hdf5</span> <span class="o">=</span> <span class="n">binnedData</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># create file and save data</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;w-&quot;</span>  <span class="c1"># fail if file exists</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;experiment/xyt_data&quot;</span><span class="p">,</span>
            <span class="n">data2hdf5</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

        <span class="n">dset</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">data2hdf5</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Created file &quot;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">)</span>

<div class="viewcode-block" id="DldProcessor.deleteBinners"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.deleteBinners">[docs]</a>    <span class="k">def</span> <span class="nf">deleteBinners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; DEPRECATED in favour of resetBins</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: deleteBinners method has been renamed to resetBins.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resetBins</span><span class="p">()</span></div>

<div class="viewcode-block" id="DldProcessor.readDataframesParquet"><a class="viewcode-back" href="../../library/DldProcessor.html#processor.DldProcessor.DldProcessor.readDataframesParquet">[docs]</a>    <span class="k">def</span> <span class="nf">readDataframesParquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; DEPRECATED: load data from a dask Parquet dataframe.</span>

<span class="sd">        DEPRECATED, use readDataframesParquet instead.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fileName (str): name (including path) of the folder containing</span>
<span class="sd">                parquet files where the data was saved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: remove this function once retro-compatibility is ensured</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="s1">&#39;WARNING: readDataframesParquet is being removed.</span><span class="se">\n</span><span class="s1">Use readDataframes instead: Default behaviour is now parqet.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39; Specify format=&quot;h5&quot; for legacy use.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">readDataframes</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span></div></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">HextofOfflineAnalyzer 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, momentoscope team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
    </div>
  </body>
</html>